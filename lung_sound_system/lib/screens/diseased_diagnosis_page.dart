import 'dart:io';
import 'dart:typed_data';
import 'package:flutter/material.dart';
import 'package:pdf/pdf.dart';
import 'package:pie_chart/pie_chart.dart';
import 'package:path_provider/path_provider.dart';
import 'package:pdf/widgets.dart' as pw;
import 'package:printing/printing.dart';
import 'package:flutter/services.dart' show rootBundle;
import 'package:firebase_auth/firebase_auth.dart';
import 'package:cloud_firestore/cloud_firestore.dart';

class DiseasedDiagnosisPage extends StatefulWidget {
  final Map<String, dynamic> patient;
  final List<String> diseases;
  final List<double> probabilities;

  const DiseasedDiagnosisPage({
    super.key,
    required this.patient,
    required this.diseases,
    required this.probabilities,
  });

  @override
  State<DiseasedDiagnosisPage> createState() => _DiseasedDiagnosisPageState();
}

class _DiseasedDiagnosisPageState extends State<DiseasedDiagnosisPage> {
  bool _showAll = false;
  bool _isGeneratingPdf = false;
  bool _isSaving = false;

  Future<Uint8List> _getImageBytes() async {
    try {
      final byteData = await rootBundle.load('assets/splash_image.png');
      return byteData.buffer.asUint8List();
    } catch (e) {
      throw Exception('Failed to load logo image: $e');
    }
  }

  Future<void> _generateAndSavePdf() async {
    setState(() => _isGeneratingPdf = true);
    
    try {
      final pdf = pw.Document();
      final logo = pw.MemoryImage(await _getImageBytes());

      // Patient details
      final patientInfo = [
        'Name: ${widget.patient['name']}',
        'NIC: ${widget.patient['nic']}',
        'Gender: ${widget.patient['gender']}',
        'Birth Date: ${widget.patient['birthDate']}',
        'Home Town: ${widget.patient['homeTown']}',
        'Phone: ${widget.patient['phone']}',
      ];

      // Disease data for chart
      final topDiseases = widget.diseases.take(3).toList();
      final topProbs = widget.probabilities.take(3).toList();
      final diseaseData = {
        for (int i = 0; i < topDiseases.length; i++) 
          topDiseases[i]: topProbs[i] * 100,
      };

      pdf.addPage(
        pw.Page(
          build: (pw.Context context) {
            return pw.Column(
              crossAxisAlignment: pw.CrossAxisAlignment.start,
              children: [
                pw.Center(child: pw.Image(logo, width: 150, height: 150)),
                pw.SizedBox(height: 20),
                pw.Text('Patient Diagnosis Report', 
                  style: pw.TextStyle(fontSize: 22, fontWeight: pw.FontWeight.bold)),
                pw.Divider(),
                pw.Text('*Note: This report is generated by PulmoSense AI and should be reviewed by a medical professional.', 
                  style: pw.TextStyle(fontWeight: pw.FontWeight.bold, color: PdfColors.red)),
                pw.SizedBox(height: 20),
                pw.Text('Patient Information:', 
                  style: pw.TextStyle(fontWeight: pw.FontWeight.bold)),
                pw.SizedBox(height: 10),
                pw.Column(
                  crossAxisAlignment: pw.CrossAxisAlignment.start,
                  children: patientInfo
                      .map((info) => pw.Text(info))
                      .toList(),
                ),
                pw.SizedBox(height: 20),
                pw.Text('Diagnosis Results:', 
                  style: pw.TextStyle(fontWeight: pw.FontWeight.bold)),
                pw.SizedBox(height: 10),
                pw.Text('Detected Lung Conditions:',
                  style: pw.TextStyle(fontWeight: pw.FontWeight.bold)),
                pw.SizedBox(height: 10),
                ...widget.diseases.asMap().entries.map((entry) {
                  final index = entry.key;
                  final disease = entry.value;
                  final prob = (widget.probabilities[index] * 100).toStringAsFixed(2);
                  return pw.Padding(
                    padding: const pw.EdgeInsets.only(bottom: 5),
                    child: pw.Text('$disease: $prob%'),
                  );
                }),
                pw.SizedBox(height: 20),
                pw.Text('Top Conditions Probability Distribution',
                  style: pw.TextStyle(fontWeight: pw.FontWeight.bold)),
                pw.SizedBox(height: 10),
                pw.Center(
                  child: pw.Container(
                    height: 150,
                    child: pw.Chart(
                      title: pw.Text('Disease Probability'),
                      grid: pw.CartesianGrid(
                        xAxis: pw.FixedAxis.fromStrings(diseaseData.keys.toList()),
                        yAxis: pw.FixedAxis([0, 25, 50, 75, 100]),
                      ),
                      datasets: [
                        pw.BarDataSet(
                          color: PdfColor.fromInt(0xFFFF0000),
                          width: 40,
                          data: diseaseData.entries
                              .map((e) => pw.PointChartValue(widget.diseases.indexOf(e.key).toDouble(), e.value))
                              .toList(),
                        ),
                      ],
                    ),
                  ),
                ),
                pw.SizedBox(height: 20),
                pw.Text('Note: This report is generated by PulmoSense AI and should be reviewed by a medical professional.',
                  style: pw.TextStyle(fontStyle: pw.FontStyle.italic)),
              ],
            );
          },
        ),
      );

      final output = await getTemporaryDirectory();
      final file = File("${output.path}/diagnosis_report_${DateTime.now().millisecondsSinceEpoch}.pdf");
      await file.writeAsBytes(await pdf.save());
      
      await Printing.sharePdf(
        bytes: await pdf.save(),
        filename: 'diagnosis_report.pdf',
      );
    } catch (e) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text('PDF Generation Failed: ${e.toString()}')),
      );
    } finally {
      setState(() => _isGeneratingPdf = false);
    }
  }

  Future<void> _saveDiagnosisToFirestore() async {
    setState(() => _isSaving = true);
    
    try {
      final user = FirebaseAuth.instance.currentUser;
      if (user == null) throw Exception('User not authenticated');

      // Verify patient exists and belongs to user
      final patientDoc = await FirebaseFirestore.instance
          .collection('patients')
          .where('nic', isEqualTo: widget.patient['nic'])
          .where('uid', isEqualTo: user.uid)
          .limit(1)
          .get();

      if (patientDoc.docs.isEmpty) {
        throw Exception('Patient record not found or access denied');
      }

      final visitData = {
        'uid': user.uid,
        'patientId': widget.patient['nic'],
        'patientName': widget.patient['name'],
        'diseases': widget.diseases,
        'probabilities': widget.probabilities,
        'timestamp': FieldValue.serverTimestamp(),
        'created_at': FieldValue.serverTimestamp(),
        'type': 'diagnosis',
      };

      await FirebaseFirestore.instance.collection('visits').add(visitData);

      Navigator.pop(context, {
        'status': 'success',
        'visitData': visitData,
      });

      ScaffoldMessenger.of(context).showSnackBar(
  SnackBar(
    backgroundColor: Colors.green[600],
    behavior: SnackBarBehavior.floating,
    margin: const EdgeInsets.symmetric(horizontal: 20, vertical: 10),
    shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
    content: Row(
      children: const [
        Icon(Icons.check_circle, color: Colors.white),
        SizedBox(width: 12),
        Expanded(
          child: Text(
            'Diagnosis saved successfully!',
            style: TextStyle(
              color: Colors.white,
              fontWeight: FontWeight.bold,
            ),
          ),
        ),
      ],
    ),
    duration: Duration(seconds: 3),
  ),
);

    } catch (e) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text('Save Failed: ${e.toString()}')),
      );
    } finally {
      setState(() => _isSaving = false);
    }
  }

  @override
  Widget build(BuildContext context) {
    final topDiseases = widget.diseases.take(3).toList();
    final topProbs = widget.probabilities.take(3).toList();
    final dataMap = {
      for (var i = 0; i < topDiseases.length; i++) 
        topDiseases[i]: topProbs[i] * 100,
    };

    return Scaffold(
      appBar: AppBar(
        title: const Text("Diseased Diagnosis", 
          style: TextStyle(color: Colors.white, fontWeight: FontWeight.bold)),
        centerTitle: true,
        backgroundColor: const Color(0xFF1C1C1E),
        leading: IconButton(
          icon: const Icon(Icons.arrow_back, color: Colors.white),
          onPressed: () => Navigator.of(context).pop(),
        ),
        actions: [
          _buildSaveButton(),
          _buildPdfButton(),
        ],
      ),
      backgroundColor: const Color(0xFF1C1C1E),
      body: _buildBodyContent(dataMap),
    );
  }

  Widget _buildSaveButton() {
    return IconButton(
      icon: _isSaving 
          ? const CircularProgressIndicator(
              valueColor: AlwaysStoppedAnimation<Color>(Colors.white),
              strokeWidth: 2)
          : const Icon(Icons.save, color: Colors.white),
      onPressed: _isSaving ? null : _saveDiagnosisToFirestore,
      tooltip: 'Save Diagnosis',
    );
  }

  Widget _buildPdfButton() {
    return IconButton(
      icon: _isGeneratingPdf
          ? const CircularProgressIndicator(
              valueColor: AlwaysStoppedAnimation<Color>(Colors.white),
              strokeWidth: 2)
          : const Icon(Icons.picture_as_pdf, color: Colors.white),
      onPressed: _isGeneratingPdf ? null : _generateAndSavePdf,
      tooltip: 'Generate PDF Report',
    );
  }

  Widget _buildBodyContent(Map<String, double> dataMap) {
    return SingleChildScrollView(
      padding: const EdgeInsets.all(16),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          _buildAppLogo(),
          _buildDescriptionText(),
          _buildPieChart(dataMap),
          _buildDiseaseList(),
          _buildShowMoreButton(),
          _buildDisclaimer(),
        ],
      ),
    );
  }

  Widget _buildAppLogo() {
    return Center(
      child: Image.asset(
        'assets/splash_image.png',
        width: 150,
        height: 150,
      ),
    );
  }

  Widget _buildDescriptionText() {
    return const Padding(
      padding: EdgeInsets.symmetric(vertical: 16),
      child: Text(
        "This page provides diagnosis results based on the uploaded lung sound.",
        style: TextStyle(color: Colors.white70, fontSize: 14),
        textAlign: TextAlign.justify,
      ),
    );
  }

  Widget _buildPieChart(Map<String, double> dataMap) {
    return PieChart(
      dataMap: dataMap,
      chartType: ChartType.disc,
      chartValuesOptions: const ChartValuesOptions(
        showChartValuesInPercentage: true,
        showChartValueBackground: false,
        showChartValuesOutside: true,
        chartValueStyle: TextStyle(
          color: Colors.white,
          fontWeight: FontWeight.bold,
        ),
      ),
      colorList: const [
        Colors.redAccent,
        Colors.orangeAccent,
        Colors.yellowAccent,
      ],
      legendOptions: const LegendOptions(
        legendPosition: LegendPosition.right,
        showLegends: true,
        legendTextStyle: TextStyle(color: Colors.white),
      ),
    );
  }

  Widget _buildDiseaseList() {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: List.generate(
        _showAll ? widget.diseases.length : 1,
        (index) => _buildDiseaseTile(index),
      ),
    );
  }

  Widget _buildDiseaseTile(int index) {
    return Container(
      margin: const EdgeInsets.only(bottom: 10),
      padding: const EdgeInsets.all(12),
      decoration: BoxDecoration(
        color: const Color(0xFF2C2C2E),
        borderRadius: BorderRadius.circular(10),
      ),
      child: ListTile(
        leading: const Icon(Icons.coronavirus_outlined, color: Colors.redAccent),
        title: Text(
          widget.diseases[index],
          style: const TextStyle(
            color: Colors.white,
            fontWeight: FontWeight.bold,
          ),
        ),
        subtitle: Text(
          'Probability: ${(widget.probabilities[index] * 100).toStringAsFixed(2)}%',
          style: const TextStyle(color: Colors.white70),
        ),
      ),
    );
  }

  Widget _buildShowMoreButton() {
    return Center(
      child: TextButton(
        onPressed: () => setState(() => _showAll = !_showAll),
        child: Text(
          _showAll ? 'Show less' : 'Show more',
          style: const TextStyle(color: Colors.blueAccent),
        ),
      ),
    );
  }

  Widget _buildDisclaimer() {
    return const Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Divider(color: Colors.white30),
        Text('Note:', style: TextStyle(fontWeight: FontWeight.bold, color: Colors.white70)),
        Text(
          'This application is capable of diagnosing only 10 lung diseases:\n'
          'Asthma, Bronchiectasis, Bronchiolitis, Bronchitis, COPD, Lung Fibrosis, '
          'Pleural Effusion, Pneumonia, URTI.\n\n'
          'Please consult a medical professional before taking any medication based on this result.',
          style: TextStyle(color: Colors.white60),
        ),
      ],
    );
  }
}